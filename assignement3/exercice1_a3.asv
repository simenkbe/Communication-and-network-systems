%Simulate the first scenario (Eb /No = 8 dB is enough). Plot the simulated curve.

clear; clc; close all;

%% 1. Initialization and Parameters
N = 8;                  [cite_start]% Spreading factor (Length of the code) [cite: 20]
EbNo_dB = 0:1:12;       [cite_start]% Eb/N0 range in dB (0 to 12 dB) [cite: 44]
numBits = 100000;       % Number of bits to simulate per SNR point
                        % (Higher number = smoother curve at high SNR)

% Initialize BER result vectors
BER_simulated = zeros(size(EbNo_dB));

%% 2. User 1 Configuration
[cite_start]% Generate random binary sequence C1 of length N=8 [cite: 20]
[cite_start]% Convert to bipolar sequence c1_prime (+1, -1) [cite: 20]
c1_binary = randi([0, 1], N, 1);
c1_prime = 2 * c1_binary - 1; 

% Calculate Bit Energy (Eb)
% Since the spreading code is bipolar (+-1), its energy is the sum of squares
Eb = sum(abs(c1_prime).^2); % Eb = N

%% 3. Simulation Loop over Eb/N0
disp('Starting Simulation for Scenario 1...');

for k = 1:length(EbNo_dB)
    
    % --- A. Channel Setup ---
    % Convert Eb/N0 from dB to linear scale
    SNR_lin = 10^(EbNo_dB(k) / 10);
    
    % Calculate Noise Power Spectral Density (N0) derived from Eb/N0
    N0 = Eb / SNR_lin;
    
    % Calculate Noise Variance (sigma^2) for AWGN
    % For real signals, Variance = N0 / 2
    noise_variance = N0 / 2;
    noise_sigma = sqrt(noise_variance);
    
    % --- B. Transmitter (Tx) ---
    [cite_start]% Generate random information bits for User 1 (Bipolar: -1, +1) [cite: 21]
    tx_bits = 2 * randi([0, 1], 1, numBits) - 1;
    
    [cite_start]% Spreading: Multiply each bit by the spreading sequence c1_prime [cite: 21]
    % Result is a matrix of size (N x numBits)
    tx_signal = c1_prime * tx_bits; 
    
    % --- C. Channel ---
    [cite_start]% Generate Noise vector (N real values per bit) [cite: 22]
    noise = noise_sigma * randn(N, numBits);
    
    % Add noise to the transmitted signal
    rx_signal = tx_signal + noise;
    
    % --- D. Receiver (Rx) ---
    [cite_start]% Project received vector r over c1_prime (Dot product) [cite: 23]
    % We compute c1_prime' * rx_signal
    decision_metric = c1_prime' * rx_signal;
    
    [cite_start]% Decision based on the sign [cite: 23]
    estimated_bits = sign(decision_metric);
    
    % --- E. Error Counting ---
    [cite_start]% Compare received bit with transmitted bit [cite: 24]
    errors = sum(estimated_bits ~= tx_bits);
    BER_simulated(k) = errors / numBits;
    
end

% 4. Analytic Curve
[cite_start]% Theoretical BER for 2-PAM (BPSK equivalent) [cite: 45-46]
% Formula: P(e) = 0.5 * erfc(sqrt(Eb/N0))
SNR_lin_vect = 10.^(EbNo_dB ./ 10);
BER_analytic = 0.5 * erfc(sqrt(SNR_lin_vect));

% 5. Plotting Results
figure;
semilogy(EbNo_dB, BER_simulated, 'ko-', 'LineWidth', 1.5, 'MarkerSize', 8); hold on;
semilogy(EbNo_dB, BER_analytic, 'r--', 'LineWidth', 2);
grid on;

[cite_start]% Formatting the plot [cite: 44]
title('Scenario 1: Single User DSSS BER');
xlabel('E_b/N_0 [dB]');
ylabel('Bit Error Rate (BER)');
legend('Simulation', 'Analytic (2-PAM)', 'Location', 'SouthWest');
axis([0 12 10^-8 1]); [cite_start]% Adjust axis to look like the example [cite: 50]

disp('Simulation Scenario 1 Completed.');